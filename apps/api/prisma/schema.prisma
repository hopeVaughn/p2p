generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// User roles (e.g., admin, user, super)
enum RoleName {
  SUPER
  ADMIN
  USER
}

/// Bathroom Gender Options
enum BathroomGender {
  GENDERED
  GENDER_NEUTRAL
  BOTH
}

/// Bathroom Stall Types
enum StallType {
  SINGLE_STALL
  CONNECTED
}

/// Registered users of the application
model User {
  id                    String         @id @default(uuid()) @db.VarChar(36)
  email                 String         @unique
  password              String
  bathrooms             Bathroom[]     @relation("createdBathrooms")
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  tokens                Token[]
  roles                 UserRole[]
  verifiedVerifications Verification[]
  ratedRatings          Rating[]
  reportedReports       Report[]
  userReports           UserReport[]
}

/// Public bathrooms added by users
model Bathroom {
  id                   String         @id @default(uuid()) @db.VarChar(36)
  createdBy            User?          @relation(fields: [createdById], references: [id], name: "createdBathrooms")
  createdById          String?
  gender               BathroomGender
  stallType            StallType
  wheelchairAccessible Boolean
  stars                Float
  keyRequirement       Boolean
  hoursOfOperation     String
  latitude             Float
  longitude            Float
  address              String
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt
  ratings              Rating[]
  reports              Report[]
  verifications        Verification[]

  @@index([latitude, longitude])
}

/// Verification of bathroom by user
model Verification {
  id           String   @id @default(uuid()) @db.VarChar(36)
  bathroom     Bathroom @relation(fields: [bathroomId], references: [id], onDelete: Cascade)
  bathroomId   String
  verifiedBy   User     @relation(fields: [verifiedById], references: [id], onDelete: Cascade)
  verifiedById String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

/// Rating of bathroom by user
model Rating {
  id         String   @id @default(uuid()) @db.VarChar(36)
  bathroom   Bathroom @relation(fields: [bathroomId], references: [id], onDelete: Cascade)
  bathroomId String
  ratedBy    User     @relation(fields: [ratedById], references: [id], onDelete: Cascade)
  ratedById  String
  stars      Float
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

/// Report of false bathroom location by another user
model Report {
  id           String       @id @default(uuid()) @db.VarChar(36)
  bathroom     Bathroom     @relation(fields: [bathroomId], references: [id], onDelete: Cascade)
  bathroomId   String
  reportedBy   User         @relation(fields: [reportedById], references: [id], onDelete: Cascade)
  reportedById String
  reason       String
  userReports  UserReport[]
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
}

/// Assignment of roles to users
model UserRole {
  id        String   @id @default(uuid()) @db.VarChar(36)
  role      RoleName @default(USER)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// UserReport model for reporting false information
model UserReport {
  id        String   @id @default(uuid()) @db.VarChar(36)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  report    Report   @relation(fields: [reportId], references: [id], onDelete: Cascade)
  reportId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Token {
  id     String   @id @default(uuid())
  userId String
  user   User     @relation(fields: [userId], references: [id])
  jti    String   @unique @default(uuid())
  token  String
  expiry DateTime

  @@map("tokens")
}
